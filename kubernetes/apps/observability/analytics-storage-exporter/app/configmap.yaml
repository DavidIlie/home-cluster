---
apiVersion: v1
kind: ConfigMap
metadata:
  name: analytics-storage-exporter-script
data:
  exporter.py: |
    #!/usr/bin/env python3
    import http.server
    import os
    import subprocess
    import time
    import threading

    STORAGE_PATH = "/storage"
    metrics_cache = ""
    cache_lock = threading.Lock()

    def scan_storage():
        lines = []
        lines.append("# HELP analytics_storage_bytes Bytes used by directory")
        lines.append("# TYPE analytics_storage_bytes gauge")
        lines.append("# HELP analytics_storage_capacity_bytes Total capacity in bytes")
        lines.append("# TYPE analytics_storage_capacity_bytes gauge")
        lines.append("# HELP analytics_storage_available_bytes Available space in bytes")
        lines.append("# TYPE analytics_storage_available_bytes gauge")
        lines.append("# HELP analytics_storage_used_bytes Total used space in bytes")
        lines.append("# TYPE analytics_storage_used_bytes gauge")

        # Get filesystem stats
        try:
            st = os.statvfs(STORAGE_PATH)
            capacity = st.f_frsize * st.f_blocks
            available = st.f_frsize * st.f_bavail
            used = capacity - (st.f_frsize * st.f_bfree)
            lines.append(f'analytics_storage_capacity_bytes {capacity}')
            lines.append(f'analytics_storage_available_bytes {available}')
            lines.append(f'analytics_storage_used_bytes {used}')
        except Exception:
            pass

        # Scan top-level directories
        try:
            for entry in sorted(os.scandir(STORAGE_PATH), key=lambda e: e.name):
                if not entry.is_dir():
                    continue
                top_name = entry.name
                result = subprocess.run(
                    ["du", "-sb", entry.path],
                    capture_output=True, text=True, timeout=60
                )
                if result.returncode == 0:
                    size = int(result.stdout.split()[0])
                    lines.append(f'analytics_storage_bytes{{path="{top_name}"}} {size}')

                # Scan sub-directories
                try:
                    for sub in sorted(os.scandir(entry.path), key=lambda e: e.name):
                        if not sub.is_dir():
                            continue
                        result = subprocess.run(
                            ["du", "-sb", sub.path],
                            capture_output=True, text=True, timeout=60
                        )
                        if result.returncode == 0:
                            size = int(result.stdout.split()[0])
                            lines.append(f'analytics_storage_bytes{{path="{top_name}/{sub.name}"}} {size}')
                except PermissionError:
                    pass
        except Exception:
            pass

        return "\n".join(lines) + "\n"

    def update_loop():
        global metrics_cache
        while True:
            try:
                new_metrics = scan_storage()
                with cache_lock:
                    metrics_cache = new_metrics
            except Exception:
                pass
            time.sleep(120)

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path == "/metrics":
                with cache_lock:
                    data = metrics_cache
                self.send_response(200)
                self.send_header("Content-Type", "text/plain; version=0.0.4")
                self.end_headers()
                self.wfile.write(data.encode())
            elif self.path == "/health":
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b"ok")
            else:
                self.send_response(404)
                self.end_headers()

        def log_message(self, fmt, *args):
            pass

    if __name__ == "__main__":
        t = threading.Thread(target=update_loop, daemon=True)
        t.start()
        # Wait for first scan
        time.sleep(1)
        server = http.server.HTTPServer(("0.0.0.0", 8000), Handler)
        print("Serving metrics on :8000/metrics")
        server.serve_forever()
